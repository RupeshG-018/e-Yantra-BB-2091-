def sysCall_init():
    sim = require('sim')

    # do some initialization here
    # This function will be executed once when the simulation starts
    
    # Instead of using globals, you can do e.g.:
    # self.myVariable = 21000000
    
    ######## ADD YOUR CODE HERE #######
    # Hint: Initialize the scene objects which you will require
    #       Initialize algorithm related variables heres
    self.body = sim.getObject('/body')
    self.cone=sim.getObject('/Cone')
    self.floor = sim.getObject('/Floor')
    self.right_joint = sim.getObject('/right_joint')
    self.left_joint = sim.getObject('/left_joint')
    self.right_wheel = sim.getObject('/right_wheel')
    self.left_wheel = sim.getObject('/left_wheel')

    #State Variables
    self.x = 0
    self.x_dot = 0
    self.theta_right_wheel = 0
    self.theta_left_wheel = 0
    self.theta = 0
    self.theta_dot = 0
    self.phi = 0
    self.phi_dot = 0
    self.x1 = 0
    self.x2 = 0
    self.x3 = 0
    self.x4 = 0
    self.x5 = 0
    self.x6 = 0
    self.U = 0
    self.Ur = 0
    self.Ul = 0 
    self.key = ''
    
    ##################################
    pass
    
def sysCall_actuation():
    # put your actuation code here
    # This function will be executed at each simulation time step

    ####### ADD YOUR CODE HERE ######
    # Hint: Use the error feedback and apply control algorithm here
    #       Provide the resulting actuation as input to the actuator joint
    # Example psuedo code:
    #   x1 = error_state_1; # Error in states w.r.t desired setpoint
    #   x2 = error_state_2;
    #   x3 = error_state_3;
    #   x4 = error_state_4;
    #   k = [gain_1 , gain_1, gain_3, gain_4];      # These gains will be generated by control algorithm. For ex: LQR, PID, etc.
    #   U = -k[1]*x1 +k[2]*x2 -k[3]*x3 +k[4]*x4;    # +/- Sign convention may differ according to implementation
    #   Set_joint_actuation(U);                     # Provide this calculated input to system's actuator

    self.x1 = -self.theta
    self.x2 = -self.theta_dot
    self.x3 = -self.phi
    self.x4 = -self.phi_dot
    
    k = [-0.44721,-1.5028,-64.755,-6.4064]
    self.U = k[0]*self.x1 + k[1]*self.x2 + k[2]*self.x3 + k[3]*self.x4
    
    sim.setJointTargetVelocity(self.right_joint , -self.U + self.Ur)
    sim.setJointTargetVelocity(self.left_joint , -self.U + self.Ul)

    if self.key == 'forward':
        self.Ur-=10
        self.Ul-=10 # Move forward
    elif self.key == 'backward':
        self.Ur+=10
        self.Ul+=10 # Move backward
    elif self.key == 'left':
        self.Ur-=2
        self.Ul+=2
    elif self.key == 'right':
        self.Ur+=2
        self.Ul-=2
    self.key = ''
    
    #################################
    pass

def sysCall_sensing():
    # put your sensing code here
    # This function will be executed at each simulation time step
    
    ####### ADD YOUR CODE HERE ######
    # Hint: Take feedback here & do the error calculation
    self.x = sim.getObjectPosition(self.body, sim.handle_world)[1]
    self.x_dot = sim.getObjectVelocity(self.body)[0][1]
    self.theta_right_wheel=sim.getObjectOrientation(self.right_wheel, self.floor)[2]
    self.theta_left_wheel=sim.getObjectOrientation(self.left_wheel, self.floor)[2]
    self.theta = (self.theta_right_wheel + self.theta_left_wheel)/2
    self.theta_dot_right_wheel = sim.getVelocity(self.right_wheel)[1][0]
    self.theta_dot_left_wheel = sim.getVelocity(self.left_wheel)[1][0]
    self.theta_dot = (self.theta_dot_right_wheel + self.theta_dot_left_wheel)/2
    self.phi = sim.getObjectOrientation(self.body,self.floor)[0]
    self.phi_dot = sim.getVelocity(self.body)[1][0]

    ############### Keyboard Input ##############
    message, data, data2 = sim.getSimulatorMessage()

    if (message == sim.message_keypress):
        if (data[0] == 2007):  # forward up arrow
            self.key = 'forward' 
        if (data[0] == 2008):  # backward down arrow
            self.key = 'backward'
        if (data[0] == 2009):  # left arrow key
            self.key = 'left'
        if (data[0] == 2010):  # right arrow key
            self.key = 'right'
    else:
        # Handle other message types if necessary
        pass

    #########################################
    pass

def sysCall_cleanup():
    # do some clean-up here
    # This function will be executed when the simulation ends
    
    ####### ADD YOUR CODE HERE ######
    # Any cleanup (if required) to take the scene back to it's original state after simulation
    # It helps in case simulation fails in an unwanted state.
    #################################
    pass

# See the user manual or the available code snippets for additional callback functions?and?details