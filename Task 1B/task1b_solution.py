def sysCall_init():
    sim = require('sim')

    # do some initialization here
    # This function will be executed once when the simulation starts
    
    # Instead of using globals, you can do e.g.:
    # self.myVariable = 21000000
    
    ######## ADD YOUR CODE HERE #######
    # Hint: Initialize the scene objects which you will require
    #       Initialize algorithm related variables here
    self.body = sim.getObject('/body')
    self.right_joint = sim.getObject('/right_joint')
    self.left_joint = sim.getObject('/left_joint')
    self.left_wheel = sim.getObject('/left_wheel')
    self.right_wheel = sim.getObject('/right_wheel')
    
    self.initial_x = sim.getObjectPosition(self.body,sim.handle_world)[1]
    self.initial_theta = sim.getObjectOrientation(self.body,sim.handle_world)[0]
    self.setpoint_x = self.initial_x
    self.setpoint_theta = self.initial_theta
    self.x = 0
    self.x_dot = 0
    self.theta = 0
    self.theta_dot = 0
    self.phi = 0
    self.phi_dot = 0
    ##################################
    
def sysCall_actuation():
    # put your actuation code here
    # This function will be executed at each simulation time step

    ####### ADD YOUR CODE HERE ######
    # Hint: Use the error feedback and apply control algorithm here
    #       Provide the resulting actuation as input to the actuator joint
    
    # Example psuedo code:
    #   x1 = error_state_1; # Error in states w.r.t desired setpoint
    #   x2 = error_state_2;
    #   x3 = error_state_3;
    #   x4 = error_state_4;
    #   k = [gain_1 , gain_1, gain_3, gain_4];      # These gains will be generated by control algorithm. For ex: LQR, PID, etc.
    #   U = -k[1]*x1 +k[2]*x2 -k[3]*x3 +k[4]*x4;    # +/- Sign convention may differ according to implementation
    #   Set_joint_actuation(U);                     # Provide this calculated input to system's actuator
    k = [-8.9443*10,-97.3427*5,14.1026*10,9.2638]
    x1 = self.x
    x2 = self.x_dot
    x3 = self.theta
    x4 = self.theta_dot
    x5 = self.phi
    x6 = self.phi_dot
    X = [x1,x2,x3,x4,x5,x6]
    
    U = -(k[0]*x1+k[1]*x2+k[2]*x3+k[3]*x4)
    #print(U)
    sim.setJointTargetVelocity(self.right_joint,U)
    sim.setJointTargetVelocity(self.left_joint,U)
    #################################
    pass

def sysCall_sensing():
    # put your sensing code here
    # This function will be executed at each simulation time step
    
    ####### ADD YOUR CODE HERE ######
    # Hint: Take feedback here & do the error calculation
    self.x = sim.getObjectPosition(self.body,sim.handle_world)[1]
    self.x_dot = sim.getObjectVelocity(self.body)[0][1]
    self.theta = sim.getObjectOrientation(self.body,sim.handle_world)[0]
    self.theta_dot = sim.getObjectVelocity(self.body)[1][0]
    self.phi = sim.getObjectOrientation(self.body,sim.handle_world)[2]
    self.phi_dot = sim.getObjectVelocity(self.body,sim.handle_world)[1][2]
    #################################
    pass

def sysCall_cleanup():
    # do some clean-up here
    # This function will be executed when the simulation ends
    
    ####### ADD YOUR CODE HERE ######
    # Any cleanup (if required) to take the scene back to it's original state after simulation
    # It helps in case simulation fails in an unwanted state.
    #################################
    pass

# See the user manual or the available code snippets for additional callback functions and details
